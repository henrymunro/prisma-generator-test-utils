# generate-test-utils

A [Prisma generator](https://www.prisma.io/docs/concepts/components/prisma-schema/generators) to create some utility functions useful for writing unit/integration tests.

## Usage

Include the generator in your `prisma.schema` file:

```ts
generator testUtilGenerator {
  provider = "prisma-generate-test-utils"
  output   = "../src"
}
```

Then generate using the Prisma cli: `prisma generate`.

You'll now see some functions in the output file.

## Testing Utils

A few utilities useful for testing will be generated for you under `{output}/__testing__/prisma-generated`.

## Mock client

We will generate a mock prisma client that can be used in unit tests in place of the actual client. All methods are stubbed with `jest.fn()`.

Example:

```ts
import { makePrismaClientMock, makeUser } from './__testing/prisma-generated';

test('Test some functionallity', async () => {
  const mockPrisma = makePrismaClientMock();

  const dummyUser = makeUser();

  mockPrisma.user.findOne.mockReturnValue(dummyUser);

  someFunctionUserTest({ prisma: mockPrisma });

  expect(mockPrisma.user.findOne).toHaveBeenCalledTimes(1);
});
```

### Seed Functions

For each Model in your Prisma schema we will generate the following functions:

#### makeX

Where X is the model name, e.g. for a `User` model this would be `makeUser`. This function will assemble an object of type X and randomly generate the values based on the types specified in the Prisma schema.

The signature of this function is:

```ts
function makeX(override: Partial<X>): X {}
```

Example for a `User` model:

```ts
import { makeUser } from './__testing__/prisma-generated';

// pass no override and all required fields will be randomly generated for you
const randomUser = makeUser();

// or pass an object to override any values
const customUser = makeUser({
  id: 'some-id',
  name: 'Ellie',
  // pass any other User fields
});
```

#### seedX

Where X is the model name, e.g. for a `User` model this would be `seedUser`. This function will assemble an object of type X and randomly generate the values based on the types specified in the Prisma schema and write it to your Database.

The signature of this function is:

```ts
function seedX(override: Partial<X>): Promise<X> {}
```

Example for a `User` model:

```ts
import { seedUser } from './__testing__/prisma-generated';

// pass no override and all required fields will be randomly generated for you
const randomUser = await seedUser();

// or pass an object to override any values
const customUser = await seedUser({
  id: 'some-id',
  name: 'Ellie',
  // pass any other User fields
});
```

#### seedNXs

Where X is the model name, e.g. for a `User` model this would be `seedNUsers`. This function will assemble n objects of type X and randomly generating different values based on the types specified in the Prisma schema and write all n objects to your Database.

The signature of this function is:

```ts
function seedNXs(n: int, override: Partial<X>): Promise<X[]> {}
```

Example for a `User` model:

```ts
import { seedNUsers } from './__testing__/prisma-generated';

// pass no override and all required fields will be randomly generated for you, these fields will be different for each User
const tenRandomUser = await seedNUsers(10);

// or pass an override to specify values that should be applied to each User
const tenUsersWithTheSameName = await seedNUsers(10, {
  name: 'Ellie',
  // pass any other User fields here
});

// or pass an override function to specify different values for each {{ name }}
const tenUsersWithTheDifferentIds = await seedNUsers(10, {
  id: (index) => `some-id-${index}`,
});
```

This can be useful when seeding a bunch of stuff e.g.:

```ts
const facilities = await seedNFacilities(10);

const users = await seedNUsers(10, {
  facilityId: (i) => facilities[i].id,
});

// and so on...
```

#### deleteSeededXs

Where X is the model name, e.g. for a `User` model this would be `deleteSeededUsers`. This function will perform a cascading delete on all records that have been created by the `seedX` or `seedNXs` functions generated by this package. This is useful for clearing up after tests.

This works because each of the seed functions adds a `seeded_for_test_` prefix to the primary key before writing; we then use this to perform the delete.

> This delete is cascading meaning any records in other tables that reference the records being deleted will also be deleted.

Example for a `User` model:

```ts
import { deleteSeededUsers } from './__testing__/prisma-generated';

// in a test file
afterEach(async () => {
  await deleteSeededUsers();
});
```

### Random Value Generation

Based on the values in your Prisma schema we will randomly generate values for you.

// TODO: Document mapping between Prisma types and random generators when this has stabilised a bit.
